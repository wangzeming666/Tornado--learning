# hello.py
import tornado.httpserver
import tornado.ioloop
import tornado.options
import tornado.web

from tornado.options import define, options
define("port", default=8000, help="run on the given port", type=int)

class IndexHandler(tornado.web.RequestHandler):
    def get(self):
        greeting = self.get_argument('greeting', 'Hello')
        self.write(greeting + ', friendly user!')

if __name__ == "__main__":
    tornado.options.parse_command_line()
    app = tornado.web.Application(handlers=[(r"/", IndexHandler)])
    http_server = tornado.httpserver.HTTPServer(app)
    http_server.listen(options.port)
    tornado.ioloop.IOLoop.instance().start()
    
   
其中的 from tornado.options import define, options
       define("port", default=8000, help="run on the given port", type=int)

Tornado有一个非常有用的模块（tornado.options)来从命令行中读取设置。
在命令行中运行这个程序，python hello.py --port=8000
我们使用这个模块来指定应用监听HTTP请求的端口。
如果有一个与define语句中同名的设置在命令行中被给出，那么它将成为全局options的一个属性。
Tornado的RequestHandler类有一系列有用的内建方法，如get_argument，对HTTP的GET请求做出响应，
        greeting = self.get_argument('greeting', 'Hello')
get_argument()从一个查询字符串中取得参数greeting，如果这个参数没有出现在查询字符串内，Tornado将使用get_argument的第二个参数作为默认值
RequestHandler的另一个非常有用的方法是write，它以一个字符串作为函数的参数，并将其写入到HTTP响应中。
        if __name__ == '__main__':
            tornado.options.parse_command_line()
            app = tornado.web.Application(handlers=[(r'/', IndexHandler)])            
在这里使用Tornado的options模块来解析命令行。然后创建了一个Tornado的Appliacation类的实例。传递给Application类__init__方法最重要的参数，
就是handlers。它告诉Tornado应该用哪个类来响应请求。
        http_server = tornado.httpserver.HTTPServer(app)
        http_server.listen(options.port)
        tornado.ioloop.IOLoop.instance().start()
这一段代码很常用，     
一旦Application对象被创建，可以其传递给Tornado的HTTServer对象，然后使用命令行制定的端口监听，最后在程序准备好接收HTTP请求后，我们创建一个
Tornado的IOLoop的实例。
前面的参数handlers非常重要，它应该是一个元组组成的列表，其中每个元组的第一个元素是一个用于匹配的正则表达式，第二个元素是一个RequestHanlder类。
之所以是元组，是因为可以按需要指定任意多个元组。



import textwrap

import tornado.httpserver
import tornado.ioloop
import tornado.options
import tornado.web

from tornado.options import define, options
define("port", default=8000, help="run on the given port", type=int)

class ReverseHandler(tornado.web.RequestHandler):
    def get(self, input):
        self.write(input[::-1])

class WrapHandler(tornado.web.RequestHandler):
    def post(self):
        text = self.get_argument('text')
        width = self.get_argument('width', 40)
        self.write(textwrap.fill(text, int(width)))
        
if __name__ == "__main__":
    tornado.options.parse_command_line()
    app = tornado.web.Application(
        handlers=[
            (r"/reverse/(\w+)", ReverseHandler),
            (r"/wrap", WrapHandler)
        ]
    )
    http_server = tornado.httpserver.HTTPServer(app)
    http_server.listen(options.port)
    tornado.ioloop.IOLoop.instance().start()
    
    
在上面的代码中,Application类在handlers参数中实例化了两个Request Handler类对象。和上一个例子一样。
        app = tornado.web.Application(handlers=[
            (r"/reverse/(\w+)", ReverseHandler),
            (r"/wrap", WrapHandler)
            ])
    
正则表达式告诉Tornado匹配任何以字符串/reverse/开始并紧跟着一个或多个字母的路径。
括号的含义是让Tornado保存匹配括号里面表达式的字符串，并将其作为请求方法的一个参数传递给RequestHandler类。
